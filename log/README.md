
# 日志系统

## 主要功能

### 日志写入
这里的日志类采用了**单例模式的懒汉式**设计模式，即需要使用日志时才实例化唯一的一个日志类，并提供一个**全局访问点**来访问。

该日志类支持 **异步模式**，可以将日志写入信息推入 **阻塞队列** 中，通过后台线程异步地将日志内容写入文件。

该日志类默认支持 **同步模式**，直接将日志内容写入文件。

### 日志文件自动分割

为了防止单个日志文件过大，该日志类实现了 日志文件的自动分割功能：

> * 当日志文件的行数超过设定的最大行数（`m_split_lines`）时，自动创建一个新的日志文件继续记录，避免文件过大导致的管理和读取困难。

> * 日志也会**按照日期**进行分割，当进入新的一天时，创建一个新的日志文件，以便后续管理和查找。

### 日志缓冲区管理
在初始化时为日志创建了一个缓冲区（`m_buf`），用于格式化日志内容。写入日志前，将日志内容格式化存储到缓冲区中，然后根据同步或异步模式决定写入方式。
使用缓冲区可以提升日志写入性能，因为可以在内存中组织日志内容，再一次性写入文件，减少磁盘 I/O 操作。

### 日志内容的格式化
日志内容被格式化为标准化的时间信息加上日志级别标签的字符串，方便后续进行日志的查看和分析。
使用 `gettimeofday()` 函数获取精确的时间戳（包括秒和微秒），保证日志时间的精度。

### 后台线程管理
在异步模式下，创建了一个**后台线程**来从**阻塞队列**中获取日志并写入文件。
使用了 `pthread_create()` 来创建线程，并且通过 `pthread_detach()` 将线程设置为 **分离状态**，确保后台线程在完成后自动释放资源，不需要显式调用 `pthread_join()`。

### 日志队列管理
使用了一个 **阻塞队列 (block_queue)** 来保存待写入的日志内容。当异步模式开启时，日志内容被推入队列，后台线程从队列中取出日志进行写入。
如果队列满了，日志会被丢弃，并输出警告信息，提醒开发者日志队列的状态。这样可以有效防止队列无限增长，导致内存使用超标。

### 日志刷新功能
提供了 `flush()` 方法，用于 **强制刷新输出缓冲区**，将缓存中的日志内容立即写入文件，确保在程序异常或终止时日志不会丢失。
`flush()` 使用互斥锁确保在多线程环境中对日志文件刷新操作的线程安全。

### 错误处理与资源管理
在初始化过程中，针对文件打开失败、内存分配失败等情况都提供了合理的**错误处理逻辑**，避免程序在初始化失败后继续执行。
通过析构函数 (`~Log()`) 实现了对所有分配资源的清理，包括日志文件指针的关闭、内存的释放等，确保程序在退出时不会发生资源泄漏。

### 日志丢弃与警告机制
当日志队列满时，当前日志会被丢弃。并且对丢弃的日志进行计数，并每丢弃 100 条日志输出一次警告，提醒开发者系统负载过高。

### 线程安全
为了保证多线程环境下日志写入的安全性，类中的 写入日志和文件操作都被**互斥锁**保护。使用 `std::lock_guard<locker>` 来管理互斥锁，确保在多线程环境中不会出现数据竞争的问题。

通过线程安全的 `localtime_r()` 来替代 `localtime()`，保证在多线程环境下时间转换的安全性。

### 笔记
[4. 日志系统实现——语雀](https://www.yuque.com/u39624144/zvaea9/spen8s1qwkgtop5c?singleDoc#)

[4. 日志系统实现——CSDN](https://blog.csdn.net/Teriri_/article/details/143369029?spm=1001.2014.3001.5502)